{"ast":null,"code":"import React, { useContext } from 'react';\nvar UntabbableContext = React.createContext(false);\n\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable({\n  // Whether this Untabbable is actually active, overriding the output of\n  // `useTabIndex`.\n  active = true,\n  // Context provider children.\n  children,\n  // Whether this Untabbable should ignore ancestor Untabbable state. This is\n  // rarely what you want, unless you are setting up something with modal\n  // elements. In that case, you may want all elements behind the modal to\n  // become untabbable, but the modal element is likely to have that same\n  // Untabbable context as its ancestor (since context is preserved across\n  // portals). Thus, the content of the modal component itself should be wrapped\n  // in an Untabbable with the `reset` prop.\n  reset = false\n}) {\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\nexport { Untabbable, UntabbableContext, useTabIndex };","map":{"version":3,"names":["React","useContext","UntabbableContext","createContext","Untabbable","active","children","reset","anyParentActive","value","Boolean","createElement","Provider","useTabIndex","tabIndex","isUntabbable"],"sources":["/home/acer/Рабочий стол/FigmasTasks/mypasestast/Figmatask/node_modules/react-tabindex/dist/index.esm.js"],"sourcesContent":["import React, { useContext } from 'react';\n\nvar UntabbableContext = React.createContext(false);\n\n/**\n * A wrapper that marks a section of the component tree as unreachable via the\n * <kbd>Tab</kbd> key. It renders no element on its own and must contain a\n * single element child. By itself it does nothing, but descendants using the\n * `useTabIndex` hook will receive `-1` if there is an active Untabbable\n * ancestor.\n *\n * If you need to toggle tabbability back on, set the `active` prop to false.\n * This is preferable to conditionally inserting the Untabbable parent since it\n * keeps the component tree structure the same, avoiding remounts.\n */\n\nfunction Untabbable({\n  // Whether this Untabbable is actually active, overriding the output of\n  // `useTabIndex`.\n  active = true,\n  // Context provider children.\n  children,\n  // Whether this Untabbable should ignore ancestor Untabbable state. This is\n  // rarely what you want, unless you are setting up something with modal\n  // elements. In that case, you may want all elements behind the modal to\n  // become untabbable, but the modal element is likely to have that same\n  // Untabbable context as its ancestor (since context is preserved across\n  // portals). Thus, the content of the modal component itself should be wrapped\n  // in an Untabbable with the `reset` prop.\n  reset = false\n}) {\n  const anyParentActive = useContext(UntabbableContext); // Explicitly force value to Boolean, since users often rely on truthiness\n  // shorthand like `active={object}`, `active={array.length}`, etc.\n\n  const value = Boolean(reset ? active : active || anyParentActive);\n  return React.createElement(UntabbableContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction useTabIndex(tabIndex) {\n  const isUntabbable = useContext(UntabbableContext);\n  return isUntabbable ? -1 : tabIndex;\n}\n\nexport { Untabbable, UntabbableContext, useTabIndex };\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,UAAU,QAAQ,OAAO;AAEzC,IAAIC,iBAAiB,GAAGF,KAAK,CAACG,aAAa,CAAC,KAAK,CAAC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,UAAUA,CAAC;EAClB;EACA;EACAC,MAAM,GAAG,IAAI;EACb;EACAC,QAAQ;EACR;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,KAAK,GAAG;AACV,CAAC,EAAE;EACD,MAAMC,eAAe,GAAGP,UAAU,CAACC,iBAAiB,CAAC,CAAC,CAAC;EACvD;;EAEA,MAAMO,KAAK,GAAGC,OAAO,CAACH,KAAK,GAAGF,MAAM,GAAGA,MAAM,IAAIG,eAAe,CAAC;EACjE,OAAOR,KAAK,CAACW,aAAa,CAACT,iBAAiB,CAACU,QAAQ,EAAE;IACrDH,KAAK,EAAEA;EACT,CAAC,EAAEH,QAAQ,CAAC;AACd;AAEA,SAASO,WAAWA,CAACC,QAAQ,EAAE;EAC7B,MAAMC,YAAY,GAAGd,UAAU,CAACC,iBAAiB,CAAC;EAClD,OAAOa,YAAY,GAAG,CAAC,CAAC,GAAGD,QAAQ;AACrC;AAEA,SAASV,UAAU,EAAEF,iBAAiB,EAAEW,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}